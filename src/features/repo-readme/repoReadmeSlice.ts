import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import { HYDRATE } from 'next-redux-wrapper'

import type { AppState } from '../../app/store'
import { fetchRepoReadme } from './repoReadmeAPI'
import base64 from 'base-64';

export interface RepoReadmeModel {
  type: string;
  encoding: string;
  size: number;
  name: string;
  path: string;
  content: string;
  sha: string;
  url: string;
  git_url: string;
  html_url: string;
  download_url: string;
  _links: {
    git: string;
    self: string;
    html: string;
  }

  // additional
  username?: string;
  reponame?: string;
  decoded: string;
}

// https://redux.js.org/style-guide/#treat-reducers-as-state-machines
export interface RepoReadmeState {
  value: Record<string, RepoReadmeModel>;
  status: 'idle' | 'loading' | 'failed';
}

const initialState: RepoReadmeState = {
  value: {},
  status: 'idle',
}

export const getRepoReadmeKey = ({ username, reponame }: { username: string, reponame: string }) => `${username}/${reponame}`

export const repoReadmeAsync = createAsyncThunk<RepoReadmeModel, { username: string; reponame: string; }, {state: { repoReadme: RepoReadmeState }}>(
  'repo/fetchRepoReadme',
  async ({ username, reponame }) => {    
    const response = await fetchRepoReadme({ username, reponame})
    const decoded = base64.decode(response.data.content);
    return { ...response.data, username, reponame, decoded }
  },
  {
    condition: ({ reponame }, { getState }) => {
      const { repoReadme } = getState();

       // check if already exist
       const data = repoReadme.value[reponame];

      if (!!data) return false;
    }
  }
)

export const repoSlice = createSlice({
  name: 'repo',
  initialState,
  // Redux Toolkit allows us to write "mutating" logic in reducers. It
  // doesn't actually mutate the state because it uses the Immer library,
  // which detects changes to a "draft state" and produces a brand new
  // immutable state based off those changes
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(HYDRATE, (state, action: any) => {
      state.status = action.payload.repoReadme.status
      state.value = {...action.payload.repoReadme.value, ...state.value }
    })
      .addCase(repoReadmeAsync.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(repoReadmeAsync.fulfilled, (state, action) => {
        state.status = 'idle'
        state.value[getRepoReadmeKey({ username: action.payload.username, reponame: action.payload.reponame })] = action.payload;
      })
      .addCase(repoReadmeAsync.rejected, (state) => {
        state.status = 'failed'
      })
  },
})

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.repoReadme.value)`
export const selectRepoReadmeValue = (state: AppState) => state.repoReadme.value
export const selectRepoReadmeStatus = (state: AppState) => state.repoReadme.status

export default repoSlice.reducer
