import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import { HYDRATE } from 'next-redux-wrapper'

import type { AppState } from '../../app/store'
import { UserModel } from '../user/userSlice'
import { fetchRepoDetails } from './repoDetailsAPI'

export interface RepoLicenseModel {
  key: string;
  name: string;
  spdx_id: string;
  url: string;
  node_id: string;
}

export interface RepoOrganizationModel {
  login: string;
  id: number;
  node_id: string;
  avatar_url: string;
  gravatar_id: string;
  url: string;
  html_url: string;
  followers_url: string;
  following_url: string;
  gists_url: string;
  starred_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  events_url: string;
  received_events_url: string;
  type: string;
  site_admin: boolean;
}

export interface RepoModel {
  id: number;
  node_id: string;
  name: string;
  full_name: string;
  owner: UserModel;
  private: boolean;
  html_url: string;
  description: string;
  fork: boolean;
  url: string;
  archive_url: string;
  assignees_url: string;
  blobs_url: string;
  branches_url: string;
  collaborators_url: string;
  comments_url: string;
  commits_url: string;
  compare_url: string;
  contents_url: string;
  contributors_url: string;
  deployments_url: string;
  downloads_url: string;
  events_url: string;
  forks_url: string;
  git_commits_url: string;
  git_refs_url: string;
  git_tags_url: string;
  git_url: string;
  issue_comment_url: string;
  issue_events_url: string;
  issues_url: string;
  keys_url: string;
  labels_url: string;
  languages_url: string;
  merges_url: string;
  milestones_url: string;
  notifications_url: string;
  pulls_url: string;
  releases_url: string;
  ssh_url: string;
  stargazers_url: string;
  statuses_url: string;
  subscribers_url: string;
  subscription_url: string;
  tags_url: string;
  teams_url: string;
  trees_url: string;
  clone_url: string;
  mirror_url: string;
  hooks_url: string;
  svn_url: string;
  homepage: string;
  language: string | null;
  forks_count: number;
  forks: number;
  stargazers_count: number;
  watchers_count: number;
  watchers: number;
  size: number;
  default_branch: string;
  open_issues_count: number;
  open_issues: number;
  is_template: boolean;
  topics: string[],
  has_issues: boolean;
  has_projects: boolean;
  has_wiki: boolean;
  has_pages: boolean;
  has_downloads: boolean;
  archived: boolean;
  disabled: boolean;
  visibility: string;
  pushed_at: string;
  created_at: string;
  updated_at: string;
  permissions: {
    pull: boolean;
    push: boolean;
    admin: false;
  };
  allow_rebase_merge: boolean;
  template_repository: RepoModel;
  temp_clone_token: string;
  allow_squash_merge: boolean;
  allow_auto_merge: boolean;
  delete_branch_on_merge: boolean;
  allow_merge_commit: boolean;
  subscribers_count: number;
  network_count: number;
  license: RepoLicenseModel | null;
  organization: RepoOrganizationModel;
  parent: RepoModel;
  source: RepoModel;
}

// https://redux.js.org/style-guide/#treat-reducers-as-state-machines
export interface RepoState {
  value: RepoModel[];
  status: 'idle' | 'loading' | 'failed';
}

const initialState: RepoState = {
  value: [],
  status: 'idle',
}

export const repoDetailsAsync = createAsyncThunk<RepoModel, { username: string; reponame: string; }, {state: { repo: RepoState }}>(
  'repo/fetchRepoDetails',
  async ({ username, reponame }) => {    
    const response = await fetchRepoDetails({ username, reponame})
    return response.data
  },
  {
    condition: ({ reponame }, { getState }) => {
      const { repo } = getState();

       // check if already exist
       const data = repo.value.find(x => {
        return x.name == reponame
      })

      if (!!data) return false;
    }
  }
)

export const repoSlice = createSlice({
  name: 'repo',
  initialState,
  // Redux Toolkit allows us to write "mutating" logic in reducers. It
  // doesn't actually mutate the state because it uses the Immer library,
  // which detects changes to a "draft state" and produces a brand new
  // immutable state based off those changes
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(HYDRATE, (state, action: any) => {
      state.status = action.payload.repo.status
      state.value = [...action.payload.repo.value, ...state.value]
    })
      .addCase(repoDetailsAsync.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(repoDetailsAsync.fulfilled, (state, action) => {
        state.status = 'idle'
        
        // check if already exist
        const dataIndex = state.value.findIndex(stateData => {
          return stateData.name == action.payload.name
        })

        if (dataIndex != -1) {
          state.value[dataIndex] = action.payload;
        } else {
          state.value = [action.payload, ...state.value];
        }
      })
      .addCase(repoDetailsAsync.rejected, (state) => {
        state.status = 'failed'
      })
  },
})

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.repo.value)`
export const selectRepoValue = (state: AppState) => state.repo.value
export const selectRepoStatus = (state: AppState) => state.repo.status

export default repoSlice.reducer
