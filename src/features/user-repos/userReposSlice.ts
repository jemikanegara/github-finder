import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import { HYDRATE } from 'next-redux-wrapper'

import type { AppState } from '../../app/store'
import { fetchUserRepos } from './userReposAPI'

export interface RepoOwnerModel {
  login: string;
  id: number;
  node_id: string;
  avatar_url: string;
  gravatar_id: string;
  url: string;
  html_url: string;
  followers_url: string;
  following_url: string;
  gists_url: string;
  starred_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  events_url: string;
  received_events_url: string;
  type: string;
  site_admin: boolean;
}

export interface UserReposItem {
  id: number;
  node_id: string;
  name: string;
  full_name: string;
  private: boolean;
  html_url: string;
  description: string;
  fork: boolean;
  url: string;
  forks_url: string;
  keys_url: string;
  collaborators_url: string;
  teams_url: string;
  hooks_url: string;
  issue_events_url: string;
  events_url: string;
  assignees_url: string;
  branches_url: string;
  tags_url: string;
  blobs_url: string;
  git_tags_url: string;
  git_refs_url: string;
  trees_url: string;
  statuses_url: string;
  languages_url: string;
  stargazers_url: string;
  contributors_url: string;
  subscribers_url: string;
  subscription_url: string;
  commits_url: string;
  git_commits_url: string;
  comments_url: string;
  issue_comment_url: string;
  contents_url: string;
  compare_url: string;
  merges_url: string;
  archive_url: string;
  downloads_url: string;
  issues_url: string;
  pulls_url: string;
  milestones_url: string;
  notifications_url: string;
  labels_url: string;
  releases_url: string;
  deployments_url: string;
  created_at: string;
  updated_at: string;
  pushed_at: string;
  git_url: string;
  ssh_url: string;
  clone_url: string;
  svn_url: string;
  homepage: null;
  size: number;
  stargazers_count: number;
  watchers_count: number;
  language: string;
  has_issues: boolean;
  has_projects: boolean;
  has_downloads: boolean;
  has_wiki: boolean;
  has_pages: boolean;
  forks_count: number;
  mirror_url: null;
  archived: boolean;
  disabled: boolean;
  open_issues_count: number;
  license: {
    key: string;
    name: string;
    spdx_id: string;
    url: string;
    node_id: string;
  };
  allow_forking: boolean;
  is_template: boolean;
  topics: string[];
  visibility: string;
  forks: number;
  open_issues: number;
  watchers: number;
  default_branch: string;
  permissions: {
    admin: boolean;
    maintain: boolean;
    push: boolean;
    triage: boolean;
    pull: boolean;
  };
  owner: RepoOwnerModel;
}

export type UserReposModel = { 
  items: UserReposItem[];
  username: string;
  page?: number;
};

// https://redux.js.org/style-guide/#treat-reducers-as-state-machines
export interface UserReposState {
  value: Record<string, UserReposModel>;
  status: 'idle' | 'loading' | 'failed'
}

const initialState: UserReposState = {
  value: {},
  status: 'idle',
}

export const getUserReposKey = ({ username, page = 1 }: { username: string, page?: number }) => `username=${username}&page=${page}`

export const userReposAsync = createAsyncThunk<UserReposModel, { username: string; page: number }, {state: { userRepos: UserReposState }}>(
  'user/fetchUserRepos',
  async ({ username, page }) => {    
    const response = await fetchUserRepos({ username, page })
    return { items: response.data, username, page }
  },
  {
    condition: ({ username, page }, { getState }) => {
      const { userRepos } = getState();

      // check if already exist
      const data = userRepos.value[getUserReposKey({ username, page })];

      if (!!data) return false;
    }
  }
)

export const userSlice = createSlice({
  name: 'user',
  initialState,
  // Redux Toolkit allows us to write "mutating" logic in reducers. It
  // doesn't actually mutate the state because it uses the Immer library,
  // which detects changes to a "draft state" and produces a brand new
  // immutable state based off those changes
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(HYDRATE, (state, action: any) => {
      state.status = action.payload.userRepos.status
      state.value = {...action.payload.userRepos.value, ...state.value }
    })
      .addCase(userReposAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(userReposAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.value = {
          ...state.value,
          [getUserReposKey({ username: action.payload.username, page: action.payload.page })]: action.payload
        }
      })
      .addCase(userReposAsync.rejected, (state) => {
        state.status = 'failed'
      })
  },
})

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.user.value)`
export const selectUserReposValue = (state: AppState) => state.userRepos.value
export const selectUserReposStatus = (state: AppState) => state.userRepos.status

export default userSlice.reducer
