import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import { HYDRATE } from 'next-redux-wrapper'

import type { AppState } from '../../app/store'
import { fetchUserSearch } from './userSearchAPI'

// https://docs.github.com/en/rest/search#search-users
export interface UserSearchItem {
  login: string;
  id: number;
  node_id: string;
  avatar_url: string;
  gravatar_id: string;
  url: string;
  html_url: string;
  followers_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  received_events_url: string;
  type: string;
  score: number;
  following_url: string;
  gists_url: string;
  starred_url: string;
  events_url: string;
  site_admin: true;
}

export interface UserSearchModel {
  total_count: number;
  incomplete_results: boolean;
  items: UserSearchItem[];

  // additional field for grouping
  q?: string;
  page?: number;
}

// https://redux.js.org/style-guide/#treat-reducers-as-state-machines
export interface UserSearchState {
  value: Record<string, UserSearchModel>;
  status: 'idle' | 'loading' | 'failed';
}

const initialState: UserSearchState = {
  value: {},
  status: 'idle',
}

export const getUserSearchKey = ({ q = '', page = 1 }: { q?: string, page?: number }) => `q=${q}&page=${page}`

export const userSearchAsync = createAsyncThunk<UserSearchModel, { q: string, page: number }, {state: { userSearch: UserSearchState }}>(
  'user/fetchUserSearch',
  async ({ q, page }) => {    
    const response = await fetchUserSearch({ q, page })
    return { ...response.data, q, page }
  },
  {
    condition: ({ q, page }, { getState }) => {
      const { userSearch } = getState();

      // check if already exist
      const data = userSearch.value[getUserSearchKey({ q, page })];

      if (!!data) return false;
    }
  }
)

export const userSlice = createSlice({
  name: 'user',
  initialState,
  // Redux Toolkit allows us to write "mutating" logic in reducers. It
  // doesn't actually mutate the state because it uses the Immer library,
  // which detects changes to a "draft state" and produces a brand new
  // immutable state based off those changes
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(HYDRATE, (state, action: any) => {
      state.status = action.payload.userSearch.status
      state.value = {...action.payload.userSearch.value, ...state.value }
    })
      .addCase(userSearchAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(userSearchAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.value = {
          ...state.value,
          [getUserSearchKey({ q : action.payload.q, page: action.payload.page })]: action.payload
        }
      })
      .addCase(userSearchAsync.rejected, (state) => {
        state.status = 'failed'
      })
  },
})

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.user.value)`
export const selectUserSearchValue = (state: AppState) => state.userSearch.value
export const selectUserSearchStatus = (state: AppState) => state.userSearch.status

export default userSlice.reducer
