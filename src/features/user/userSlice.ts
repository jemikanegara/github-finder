import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import { HYDRATE } from 'next-redux-wrapper'

import type { AppState } from '../../app/store'
import { fetchUserDetails } from './userAPI'

// https://docs.github.com/en/rest/users/users#get-a-user
export interface UserModel {
  login: string;
  id: number;
  node_id: string;
  avatar_url: string;
  gravatar_id: string;
  url: string;
  html_url: string;
  followers_url: string;
  following_url: string;
  gists_url: string;
  starred_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  events_url: string;
  received_events_url: string;
  type: string;
  site_admin: boolean;
  name: string;
  company: string;
  blog: string;
  location: string;
  email: string;
  hireable: boolean;
  bio: string;
  twitter_username: string;
  public_repos: number;
  public_gists: number;
  followers: number;
  following: number;
  created_at: string;
  updated_at: string;
}

// https://redux.js.org/style-guide/#treat-reducers-as-state-machines
export interface UserState {
  value: UserModel[];
  status: 'idle' | 'loading' | 'failed';
}

const initialState: UserState = {
  value: [],
  status: 'idle',
}

export const userDetailsAsync = createAsyncThunk<UserModel, string, {state: { user: UserState }}>(
  'user/fetchUserDetails',
  async (username) => {    
    const response = await fetchUserDetails(username)
    return response.data
  },
  {
    condition: (username, { getState }) => {
      const { user } = getState();

       // check if already exist
       const data = user.value.find(x => {
        return x.login == username
      })

      if (!!data) return false;
    }
  }
)

export const userSlice = createSlice({
  name: 'user',
  initialState,
  // Redux Toolkit allows us to write "mutating" logic in reducers. It
  // doesn't actually mutate the state because it uses the Immer library,
  // which detects changes to a "draft state" and produces a brand new
  // immutable state based off those changes
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(HYDRATE, (state, action: any) => {
      state.status = action.payload.user.status
      state.value = [...action.payload.user.value, ...state.value]
    })
      .addCase(userDetailsAsync.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(userDetailsAsync.fulfilled, (state, action) => {
        state.status = 'idle'
        
        // check if already exist
        const dataIndex = state.value.findIndex(stateData => {
          return stateData.login == action.payload.login
        })

        if (dataIndex != -1) {
          state.value[dataIndex] = action.payload;
        } else {
          state.value = [action.payload, ...state.value];
        }
      })
      .addCase(userDetailsAsync.rejected, (state) => {
        state.status = 'failed'
      })
  },
})

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.user.value)`
export const selectUserValue = (state: AppState) => state.user.value
export const selectUserStatus = (state: AppState) => state.user.status

export default userSlice.reducer
